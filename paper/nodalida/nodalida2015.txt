

Introduction

We represent Constraint Grammar (Karlsson et al.1995) as a Boolean satisfiability (SAT) problem. Let us demonstrate our approach with the following example in Spanish. "<la>" "el" det def f sg "lo" prn p3 f sg "<casa>" "casa" n f sg "casar" v pri p3 sg "casar" v imp p2 sg The ambiguous passage can be either a noun phrase, la:det casa:n `the house' or a verb phrase la:prn casa:v pri p3 `(he/she) marries her'. We add the following rules: REMOVE prn IF (1 n) ; REMOVE det IF (1 v) ; Standard CG will apply one1 of the rules to the word la; either the one that comes first, or by some other heuristic. The second rule will not fire, because it would remove the last reading. All readings of casa are left untouched by these rules. SAT solver performs a search, and starts building possible models that satisfy both constraints. In addition to the given constraints, we have default rules to emulate the CG principles: an analysis is true if no rule affects it, and at least one analysis for each word is true--the notion of "last" is not applicable. With these constraints, we get two solutions: det, n and prn, v pri p3, v imp p2. The interaction of the rules regarding la disambiguates the POS of casa for free, and ordering of the rules doesn't matter.
be more cautious, we could require the word at position +1 be disambiguated fully (1C instead of 1), but in that case, neither of the rules would be applied.
1 To

The most important differences between the traditional and the SAT-based approach are summarised below: Condition of being unambiguously tagged is irrelevant. Rather than waiting for a word to get disambiguated, the SAT solver starts by making assumptions (e.g. "casa is a noun") and working under them, discarding the assumption if it doesn't lead to a model that satisfies all constraints. Rules are unordered. A typical CG rule sequence starts with rules that are either very common, or have a complex condition to fulfil. Stronger rules appear towards the end, to be applied if none of the weaker rules has. To replace the sequential order, we have experimented with different strategies: · Maximise number of rules used--We discarded this strategy, because it was too strong: if a rule leads to a conflict in one case, it was not be applied anywhere. · Emulate sequential order--Enter clauses produced by each rule one by one, and assume the solver state reached so far is correct; if a conflict is introduced by new clauses, discard them and move on to next. Maximise number of rule applications--If there is a conflict, find the smallest number of rule applications to discard so that the conflict is solved. Rules disambiguate more. In standard CG, the rules only tell to remove readings for the word which is tagged as prn or det. The SAT-based implementation interprets the rules as "noun and pronoun together are illegal", and is free to take action that concerns also the following word. This means that the rules can be flipped: compare the rules below to the ones in the example.

Text Don Quijote Pride and Prejudice

# words, rules 186460 words 261 rules 153386 words 99 rules

SATCG 2m53.7s 55.7s

VISLCG3 10.7s 4.8s

Table 1: Comparing execution times between SATCG and VISLCG3. REMOVE n IF (-1 prn) ; REMOVE v IF (-1 det) ; SAT-based approach gives identical results with both sets of rules, whereas the standard CG would remove one reading from casa and leave la ambiguous. Testing this property with more complex rules and larger rule sets than remains to be done. The heuristics worked with examples in the order of tens of rules, but moving to hundreds of rules, the rules interact more, the results are more mixed. Rule sets in order of thousands of rules remains to be tested. These three features are likely to change the way that rules are written. [TODO: more speculation, examples]


Table 2: Result of removing rules one by one, and how close to the gold standard they get. Spanish, and a small constraint grammar3 , produced independently of the authors. We only took select and remove rules (no substitute/iff), after which the constraint grammar had 261 rules. With this setup, we took the text of the tagged corpus with all ambiguities, and ran both VISLCG3 and our implementation with the same grammar. Removing rules In this experiment, we took 19 rules written by the authors, which give 83.15 % correct results with SATCG and 83.33 % with VISLCG3. Then we removed rules one by one; after getting a score for n rules, we took the combination of n - 1 rules for which SATCG gives the best score, and we ran the rule set with VISLCG3 for comparison. Table 2 shows the percentages compared to the gold standard for both systems.

2

Related work

Our work is inspired by (Lager1998), which presents constraint rules as a disjunctive logic program, and (Lager and Nivre2001), which reconstructs 4 different formalisms from a logical point of view. (Eineborg and Lindberg1998; Sfrent2014) use Inductive Logic Programming to learn CG rules from a tagged corpus. (Lager2001) discusses ordering of the CG rules.

3

Results and evaluation

Time SAT is NP-complete, whereas the standard implementations of CG are polynomial, but with advances in SAT solving techniques, the performance is much more feasible than in the previous works done in 90s­00s. We used the open-source SAT solver MiniSat (E´ en and S¨ orensson2004). Table 1 shows the execution time compared to VISL CG3. SATCG is just a first proof-of-concept implementation and can be optimised. Performance against VISL CG3 We took a tagged gold standard corpus2 of 21865 words for
2 https://svn.code.sf.net/p/apertium/svn/branches/apertiumswpost/apertium-en-es/es-tagger-data/es.tagged


