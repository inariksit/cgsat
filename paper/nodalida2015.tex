%
% File nodalida2015.tex
%
% Contact beata.megyesi@lingfil.uu.se
%
% Based on the instruction file for EACL 2014
% which in turn was based on the instruction files for previous 
% ACL and EACL conferences.

\documentclass[11pt]{article}
\usepackage{nodalida2015}
\usepackage{times}
\usepackage{mathptmx}
%\usepackage{txfonts}
\usepackage{url}
\usepackage{latexsym}
\usepackage{cite}
\special{papersize=210mm,297mm} % to avoid having to use "-t a4" with dvips 
%\setlength\titlebox{6.5cm}  % You can expand the title box if you really have to

\title{Towards ....}

\author{Inari Listenmaa \and Koen Claessen \\
  Chalmers University of Technology, Gothenburg, Sweden \\
  {\tt \{inari,koen\}@chalmers.se} }

\date{\today}

\begin{document}
\maketitle
\begin{abstract}
We implement Constraint Grammar using a SAT solver.

We experiment with different strategies to maximise the number of instances to apply rules;
this will also lead to different orderings of the rules and ways of solving conflicts.


\end{abstract}


\section{Introduction}
Constraint Grammar (CG) was first introduced by \cite{karlsson1995constraint}. 
It is a tool for disambiguating output by morphological analyser.


\section{Related work}
\label{sect:related}

Application of logic to POS tagging or shallow parsing isn't new;
\cite{lager98, lager_nivre01} present constraint rules as 
a disjunctive logic program.

Our implementation is inspired by this approach,
but unlike Lager's our implementation tries to emulate the CG
formalism in behaviour and features offered.
% What we do better: implement something that takes existing CG rules and applies them to text, trying to mimic/outperform current CG implementations.

\cite{lager01transformation} showed rules where ordering didn't matter so much in the end.



\section{Implementation using SAT solver}
\label{sect:pdf}

SAT solving is based on a technique called unit propagation:
a set of complex Boolean clauses is simplified, starting from unit
clauses, which consist of just a single variable, and working up to a
solution, where all variables in the set have a True or False value.

SAT solving is used for many applications where constraints must be
satisfied, such as software and hardware verification.

Let us demonstrate the approach with the example sentence 
\emph{the bear sleeps}. After applying morphological tagger, we get the following analyses:

\begin{verbatim}
"<the>"
        "the" det
"<bear>"
        "bear" n sg
        "bear" v pl
"<sleeps>"
        "sleep" n pl
        "sleep" v sg p3
\end{verbatim}

We make each analysis a variable; let us call them \texttt{det1}, \texttt{n2}, \texttt{v2}, \texttt{n3} and \texttt{v3} by the proposed POS tag and the position in the sentence.
For instance, \texttt{n2} is a hypothesis that the correct analysis 
for the word form ``bear'' is \texttt{"bear" n pl}.
Before applying rules, we must make sure that in each position
at least one of the analyses is true. We add our first disjunctions:

\begin{itemize}
\item [] $det1$ \\ $n2 \vee v2$ \\ $n3 \vee v3$
\end{itemize}

Let us add two rules
\begin{itemize}
\item [] \texttt{REMOVE v IF -1 det} \\ \texttt{REMOVE n IF -1 n}
\end{itemize}

Instead of applying these rules 

The condition of being unambiguously tagged becomes less necessary as well.
We add many clauses, knowing that some of them end up being false.

\subsection{Rule ordering}
\label{ssec:ordering}

Ordering and conflicts : the most important differences here

\cite{koskenniemi92}
\begin{quote}Rules in the CG formalism are typically [--] executed as successive groups.
In finite-state syntax, rules are logically unordered.\end{quote}

% VISLCG ad hoc ordering:
% 1. SELECT before REMOVE.
% 2. SELECT rules targetting more preferred tags before 
%   rules targetting less preferred targets.
% 3. REMOVE rules targetting less preferred tags before
 %   rules targetting more preferred targets.
% 4. By order of appearance in rule file.

In CG3, the rules are applied in the order of appearance in the rule file.

A typical CG rule sequence starts with stronger rules  

\subsection{Other experiments}

Different strategies for maximising: ...

Modifications to an existing CG to better disambiguate with our implementation

Flipping rules: 
\begin{itemize}
\item [] \texttt{REMOVE v IF -1 det} \\ $\rightarrow$ \texttt{REMOVE det IF 1 verb}   
\item [] \texttt{REMOVE adv IF NOT 1C adj} \\ $\rightarrow$ \texttt{REMOVE (*) - Adj  IF -1 adv}  \\
\end{itemize}

With this experiment, we move even further away from a direct ``if this then that'' model of CG.
% Not really CG anymore , but 

\section{Results and evaluation}



% \section*{Acknowledgments}

% Do not number the acknowledgment section. Do not include this section
% when submitting your paper for review.
% Francis Tyers

\bibliographystyle{acl}
\bibliography{cg}


\end{document}
