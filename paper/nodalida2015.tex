%
% File nodalida2015.tex
%
% Contact beata.megyesi@lingfil.uu.se
%
% Based on the instruction file for EACL 2014
% which in turn was based on the instruction files for previous 
% ACL and EACL conferences.

\documentclass[11pt]{article}
\usepackage{nodalida2015}
\usepackage{times}
\usepackage{mathptmx}
%\usepackage{txfonts}
\usepackage{url}
\usepackage{latexsym}
\usepackage{cite}
\usepackage{authordate1-4}
\special{papersize=210mm,297mm} % to avoid having to use "-t a4" with dvips 
%\setlength\titlebox{6.5cm}  % You can expand the title box if you really have to

\title{Towards something :-D}

\author{Inari Listenmaa \and Koen Claessen \\
  Chalmers University of Technology, Gothenburg, Sweden \\
  {\tt \{inari,koen\}@chalmers.se} }

\date{\today}

\begin{document}
\maketitle
\begin{abstract}
We implement Constraint Grammar as a Boolean satisfiability problem.

We experiment with different strategies to maximise the number of instances to apply rules;
this will also lead to different orderings of the rules and ways of solving conflicts.


\end{abstract}


\section{Introduction}
Constraint Grammar (CG) was first introduced by \cite{karlsson1995constraint}. 
It disambiguates output by morphological analyser, 
and has been used for many tasks in computational linguistics, such as POS tagging,
surface syntax and machine translation.
The current state-of-the-art parser VISL CG-3 is implemented (...);
in addition there are a number of finite-state based implementations \cite{nemeskey14}.

We represent CG as a Boolean satisfiability problem using the 
open-source SAT solver MiniSat \cite{een04sat}.
Our implementation is inspired by approaches like \cite{lager98,lager_nivre01},
but we try to emulate the CG formalism more closely than the previous logic-based works.

% NP-complete -- overkill for CG? But gives other benefits.

\section{Related work}
\label{sect:related}

Application of logic to POS tagging or shallow parsing isn't new;
\cite{lager98,lager_nivre01} present constraint rules as 
a disjunctive logic program.
\cite{lindberg_eineborg98ilp,asfrent14} use Inductive Logic Programming to learn CG rules from a tagged corpus.
\cite{lager01transformation} discusses ordering of the CG rules.

Works from the late 90s and early 00s mention that the method is very slow;
however, advances in SAT solving technique

\section{CG as a SAT problem}
\label{sect:pdf}

SAT solving is based on a technique called unit propagation:
a set of complex Boolean clauses is simplified, starting from unit
clauses, which consist of just a single variable, and working up to a
solution, where all variables in the set have a True or False value.
We model an ambiguous sentence as a set of clauses, where each analysis is a variable, 
and constraint rules form clauses operating on those variables.

\begin{itemize}
\item The condition of being unambiguously tagged becomes less necessary.
We add many clauses, knowing that some of them end up being false.
\item Rules are unordered. 
\item Rules interact with each other and disambiguate more than same rules in the standard implementation.
\end{itemize}

% Let us demonstrate the approach with the example sentence 
% \emph{the bear sleeps}. After applying morphological tagger, we get the following analyses:

% \begin{verbatim}
% "<the>"
%         "the" det
% "<bear>"
%         "bear" n sg
%         "bear" v pl
% "<sleeps>"
%         "sleep" n pl
%         "sleep" v sg p3
% \end{verbatim}

%We make each analysis a variable; let us call them \texttt{d1}, \texttt{n2}, \texttt{v2}, \texttt{n3} and \texttt{v3} by the proposed POS tag and the position in the sentence.
%For instance, \texttt{n2} is a hypothesis that the correct analysis 
%for the word form \emph{bear}' is \texttt{"bear" n pl}.
%Before applying rules, we must make sure that in each position
%at least one of the analyses is true. We add our first disjunctions:

%\begin{itemize}
%\item [] $d1$ \\ $n2 \vee v2$ \\ $n3 \vee v3$
%\end{itemize}

%Let us add two rules:
%\begin{itemize}
%\item [] \texttt{REMOVE v IF -1 det} \\ 
%            \texttt{REMOVE n IF -1 n} 
%\end{itemize}

%The rules are applied as implications: \emph{if ``the'' is a determiner, then ``bear'' cannot be a verb}. 
 
%\begin{itemize}
%\item [] $d1 \Rightarrow \neg v2$ \\
%           $n2   \Rightarrow \neg n3$
%\end{itemize}


\subsection{Rule ordering}
\label{ssec:ordering}

A typical CG rule sequence starts with weaker rules, and leaves stronger rules towards the end, 
to be applied if none of the weaker rules has fired.

Unordered rules are not new: finite-state implementations of CG \cite{koskenniemi92} also have logically unordered rules. 

% VISLCG ad hoc ordering:
% 1. SELECT before REMOVE.
% 2. SELECT rules targetting more preferred tags before 
%   rules targetting less preferred targets.
% 3. REMOVE rules targetting less preferred tags before
 %   rules targetting more preferred targets.
% 4. By order of appearance in rule file.

In CG3, the rules are applied in the order of appearance in the rule file.


Different strategies for maximising: ...

\subsection{Rule interaction}

The following example illustrates the interaction of rules to produce the desired outcome. We have an ambiguous passage in Spanish, with the following analyses:

\begin{verbatim}
"<la>"
        "el" det def f sg
        "lo" prn pro p3 f sg
"<casa>"
        "casa" n f sg
        "casar" vblex pri p3 sg
        "casar" vblex imp p2 sg
\end{verbatim}

We add the following rules to disambiguate the word \emph{la}:
\begin{itemize}
\item [] \texttt{REMOVE prn IF (1 n) ;} \\
             \texttt{REMOVE det IF (1 vblex) ;}
\end{itemize}

Standard CG will apply first the rule that removes the pronoun reading, because it comes first in the rule file.
The second rule will not fire, because it would remove the last reading for the word \emph{la}, and that is not allowed. To be more cautious, we could require the word at position +1 be disambiguated fully (\texttt{1C} instead of \texttt{1}), but in that case, neither of them would fire. The ambiguity between the readings of \emph{casa} is left untouched by these rules.

With the SAT clauses, we get two solutions: ``la\texttt{:det} casa\texttt{:n}''  and ``la\texttt{:prn} casa\texttt{:v}''. The interaction of the rules regarding \emph{la}  disambiguates \emph{casa} for free, and ordering of the rules doesn't matter. Since we don't have other rules nor further context, we still get two solutions, but there are no illegal combinations (\texttt{det v} or \texttt{prn n}) in one solution.

\paragraph{Rules can be flipped.}
Since implications can be presented as disjunctions, we can 
The representation of the implications as disjunctions 
\begin{itemize}
\item [] \texttt{REMOVE v IF -1 det} \\ $\rightarrow$ \texttt{REMOVE det IF 1 verb}   
\item [] \texttt{REMOVE adv IF NOT 1C adj} \\ $\rightarrow$ \texttt{REMOVE (*) - Adj  IF -1 adv}  \\
\end{itemize}

With this experiment, we move even further away from a direct ``if this then that'' model of CG.

\section{Results and evaluation}

We took small constraint grammars (\textless{}500 rules) for Spanish and English, and disambiguated a number of texts from Project Gutenberg. We compared the result of using VISLCG3 for the same task; table~\ref{table:results} shows the differences in results in both sentence and word level.

\begin{table}
  \centering
  \begin{tabular}{|r|r|r|r|r|}
     \hline
    \textbf{Text} & \textbf{Diff words} & \textbf{Diff sentences} \\
    \hline
	Pride and Prejudice & todo & 5k/7k \\  
    \hline
       Don Quijote & todo & 3k/6k  \\ 
     \hline
  \end{tabular}
  \caption{Results for comparing SATCG and VISLCG3.}
  \label{table:results}
\end{table}

The tendency of needing less rules to disambiguate shows also in a larger context with more complex rules.
In many of the differences, SATCG disambiguated more. (TODO counts)


% \section*{Acknowledgments}

% Do not number the acknowledgment section. Do not include this section
% when submitting your paper for review.
% Francis Tyers

\bibliographystyle{acl}
\bibliography{cg}


\end{document}
