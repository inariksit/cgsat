-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module BNFC.ParCG where
import BNFC.AbsCG
import BNFC.LexCG
import BNFC.ErrM

}

%name pGrammar Grammar
%name pListDef ListDef
%name pDef Def
%name pSetDecl SetDecl
%name pSetName SetName
%name pTag1 Tag1
%name pTag Tag
%name pListTag ListTag
%name pRule Rule
%name pCond Cond
%name pCond1 Cond1
%name pListCond ListCond
%name pTagSet TagSet
%name pTagSet1 TagSet1
%name pPosition Position
%name pBarrier Barrier

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token
  '(' { PT _ (TS _ 1) }
  '(*)' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  '-' { PT _ (TS _ 6) }
  ';' { PT _ (TS _ 7) }
  '=' { PT _ (TS _ 8) }
  'BARRIER' { PT _ (TS _ 9) }
  'C' { PT _ (TS _ 10) }
  'IF' { PT _ (TS _ 11) }
  'LINK' { PT _ (TS _ 12) }
  'LIST' { PT _ (TS _ 13) }
  'NOT' { PT _ (TS _ 14) }
  'OR' { PT _ (TS _ 15) }
  'REMOVE' { PT _ (TS _ 16) }
  'SELECT' { PT _ (TS _ 17) }

L_quoted { PT _ (TL $$) }
L_UIdent { PT _ (T_UIdent $$) }
L_Id { PT _ (T_Id $$) }
L_Signed { PT _ (T_Signed $$) }


%%

String  :: { String }  : L_quoted {  $1 }
UIdent    :: { UIdent} : L_UIdent { UIdent ($1)}
Id    :: { Id} : L_Id { Id ($1)}
Signed    :: { Signed} : L_Signed { Signed ($1)}

Grammar :: { Grammar }
Grammar : ListDef { Defs (reverse $1) } 


ListDef :: { [Def] }
ListDef : {- empty -} { [] } 
  | ListDef Def { flip (:) $1 $2 }


Def :: { Def }
Def : SetDecl { SetDef $1 } 
  | Rule { RuleDef $1 }


SetDecl :: { SetDecl }
SetDecl : 'LIST' SetName '=' ListTag ';' { Set $2 $4 } 


SetName :: { SetName }
SetName : UIdent { SetName $1 } 


Tag1 :: { Tag }
Tag1 : String { Lemma $1 } 
  | Id { Tag $1 }
  | SetName { Named $1 }
  | '(' Tag ')' { $2 }
  | '(' ListTag ')' { AND $2 }


Tag :: { Tag }
Tag : Tag1 { $1 } 


ListTag :: { [Tag] }
ListTag : Tag { (:[]) $1 } 
  | Tag ListTag { (:) $1 $2 }


Rule :: { Rule }
Rule : 'SELECT' TagSet 'IF' ListCond ';' { SelectIf $2 (reverse $4) } 
  | 'REMOVE' TagSet 'IF' ListCond ';' { RemoveIf $2 (reverse $4) }
  | 'SELECT' TagSet ';' { SelectAlways $2 }
  | 'REMOVE' TagSet ';' { RemoveAlways $2 }
  | String Rule { MatchLemma $1 $2 }


Cond :: { Cond }
Cond : Cond1 { C $1 } 


Cond1 :: { Cond }
Cond1 : Cond1 'LINK' Cond { Linked $1 $3 } 
  | 'NOT' Position TagSet { CNotPos $2 $3 }
  | Position TagSet { CPos $1 $2 }
  | Position TagSet Barrier { CBarrier $1 $2 $3 }
  | 'NOT' Position TagSet Barrier { CNotBar $2 $3 $4 }
  | '(' Cond ')' { $2 }


ListCond :: { [Cond] }
ListCond : {- empty -} { [] } 
  | ListCond Cond { flip (:) $1 $2 }


TagSet :: { TagSet }
TagSet : TagSet1 { TagSet $1 } 


TagSet1 :: { TagSet }
TagSet1 : '(' TagSet ')' { $2 } 
  | Tag 'OR' TagSet1 { OR $1 $3 }
  | TagSet1 '-' TagSet { Diff $1 $3 }
  | TagSet1 '+' TagSet { Cart $1 $3 }
  | '(*)' { All }
  | Tag { NilT $1 }


Position :: { Position }
Position : Signed { Exactly $1 } 
  | '*' Signed { AtLeast $2 }
  | Position 'C' { $1 }


Barrier :: { Barrier }
Barrier : 'BARRIER' TagSet { Barrier $2 } 



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

