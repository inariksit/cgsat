-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParApertium where
import AbsApertium
import LexApertium
import ErrM

}

%name pText Text
%name pListLine ListLine
%name pLine Line
%name pAnalysis Analysis
%name pListAnalysis ListAnalysis
%name pTagA TagA
%name pListTagA ListTagA

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token
  '$' { PT _ (TS _ 1) }
  '*' { PT _ (TS _ 2) }
  '/' { PT _ (TS _ 3) }
  '<' { PT _ (TS _ 4) }
  '>' { PT _ (TS _ 5) }
  '^' { PT _ (TS _ 6) }

L_Punct { PT _ (T_Punct $$) }
L_Iden { PT _ (T_Iden $$) }


%%

Punct    :: { Punct} : L_Punct { Punct ($1)}
Iden    :: { Iden} : L_Iden { Iden ($1)}

Text :: { Text }
Text : ListLine { Lines (reverse $1) } 


ListLine :: { [Line] }
ListLine : {- empty -} { [] } 
  | ListLine Line { flip (:) $1 $2 }


Line :: { Line }
Line : '^' Iden '/' ListAnalysis '$' { Line $2 $4 } 
  | Punct { LinePunct $1 }
  | '^' Iden '/' '*' Iden '$' { NoAnalysis $2 $5 }


Analysis :: { Analysis }
Analysis : Iden ListTagA { Anal $1 (reverse $2) } 


ListAnalysis :: { [Analysis] }
ListAnalysis : {- empty -} { [] } 
  | Analysis { (:[]) $1 }
  | Analysis '/' ListAnalysis { (:) $1 $3 }


TagA :: { TagA }
TagA : '<' Iden '>' { TagA $2 } 


ListTagA :: { [TagA] }
ListTagA : {- empty -} { [] } 
  | ListTagA TagA { flip (:) $1 $2 }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

