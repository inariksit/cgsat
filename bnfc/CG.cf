
comment "#" ;
comment "SETS" ;
comment "SUBREADINGS" ;
comment "CONSTRAINTS" ;
comment "MAPPINGS" ;
comment "DELIMITERS" ;
comment "SOFT-DELIMITERS" ;
comment "AFTER-SECTIONS" ;
comment "BEFORE-SECTIONS" ;
comment "NULL-SECTION" ;

-- hacks
comment "ADD" ; 
comment "IFF" ;
comment "MAP" ;
comment "SUBSTITUTE" ;



Sections. Grammar ::= [Section] ;
separator nonempty Section "SECTION" ;  --TODO: check if we can use multiple things as a separator (e.g. SECTION / BEFORE-SECTIONS / AFTER-SECTIONS

Defs.  Section ::= [Def] ;
terminator Def "" ;

--------------------------------------------------------------------------------
-- Sets and lists can be defined at the beginning of the grammar
-- Lists are bound by OR with just concatenation:
--   LIST V  = vblex vbser vaux vbhaver vbdo ; --just tags
-- 
-- Sets use "OR" or "|":
--   SET CLB = SENT | V-FIN | Subj ; --named lists

SetDef. Def  ::= SetDecl ;

Set.  SetDecl ::= "SET" SetName "=" TagSet ";" ;
List. SetDecl ::= "LIST" SetName "=" [Tag] ";" ;

-- Set names start with uppercase letter or number 
SetName.  SetName ::= UIdent ;
SetMeta.  SetName ::= "<" UIdent ">" ;
SetSynt.  SetName ::= "@" UIdent ;
BOS.      SetName ::= ">>>" ;
EOS.      SetName ::= "<<<" ;
_.        SetName ::= "$$" SetName ; -- Unification; just read them as regular set names


--------------------------------------------------------------------------------
-- Tags can be wordforms or lemmas/wordforms, identifiers or named sets.

Lemma.   Tag1 ::= Str ; 
LemmaCI. Tag1 ::= Str "i" ; 
Regex.   Tag1 ::= Str "r" ;
Tag.     Tag1 ::= Id ;
Named.   Tag1 ::= SetName ;
_.       Tag1 ::= "+" Tag1 ; -- Subreadings; ignore

coercions Tag 1 ;

separator nonempty Tag "" ;

----------------------------------------------------------------------
-- Rules: e.g.
-- REMOVE Foo IF (-1 Bar) 

RuleDef. Def ::= Rule ;

SelectIf. Rule ::= SELECT TagSet MaybeIF [Cond] ";" ;
RemoveIf. Rule ::= REMOVE TagSet MaybeIF [Cond] ";" ;
SelectAlways. Rule ::= SELECT TagSet ";" ;
RemoveAlways. Rule ::= REMOVE TagSet ";" ;
MatchLemma. Rule ::= Str Rule ; --for some reason "<az>" SELECT foo ... doesn't work with String

rules SELECT ::= "SELECT" MaybeName ;
rules REMOVE ::= "REMOVE" MaybeName ;

rules MaybeIF   ::= "IF" | "if" | ;
rules MaybeName ::= ":" Id | ;

--TODO subreading:  SELECT Inf IF (-1/0 ADV-NOT)(-1/1 VAUX-CAN);
CondNotPos.  Cond1 ::= "NOT" Position TagSet ;
CondPos.     Cond1 ::= Position TagSet ;
--CondPosSub.  Cond1 ::= Position "/" Signed TagSet ;
CondBarrier. Cond1 ::= Position TagSet "BARRIER" TagSet ;
CondCBarrier. Cond1 ::= Position TagSet "CBARRIER" TagSet ;
CondNotBar.  Cond1 ::= "NOT" Position TagSet "BARRIER" TagSet ;
CondNotCBar. Cond1 ::= "NOT" Position TagSet "CBARRIER" TagSet ;
CondLinked.  Cond  ::= [Cond1] ;
CondTempl.   Cond  ::= [Template] ;
_.           Cond ::= "(" Cond ")" ; 


separator nonempty Cond1 "LINK" ;
separator nonempty Cond "" ;

-- Template: REMOVE V-FIN IF (0 Inf) ((1C* V-FIN) OR (-1C* V-FIN));
-- OR separates here conditions, not tagsets.
Templ.    Template ::= "(" Cond1 ")" ;
separator nonempty Template "OR" ;

TagSet.  TagSet  ::= TagSet1 ;
_.       TagSet1 ::= "(" TagSet ")" ; -- you can add parentheses around any tag set

-- Essentially, tags bound by AND are like one tag.
-- These tags are separated by spaces and enclosed in parentheses.
-- Also you can just parenthesise a single tag randomly.
AND.     Tag1 ::= "(" [Tag] ")" ; 

-- OR 
OR.      TagSet1 ::= Tag Or TagSet1 ; 
Diff.    TagSet1 ::= TagSet1 "-" TagSet ;
Cart.    TagSet1 ::= TagSet1 "+" TagSet ;
All.     TagSet1 ::= "(*)" ;
NilT.    TagSet1 ::= Tag ;

rules Or ::= "OR" | "|" ;

Exactly.     Position ::= Signed ;
AtLeastPre.  Position ::= "*" Signed ;
AtLeastPost. Position ::= Signed "*" ; 
AtLPostCaut1. Position ::= Signed "C*" ;
AtLPostCaut2. Position ::= "*" Signed "C" ;
Cautious.    Position ::= Position "C" ; 
Subreading.  Position ::= Signed "/" Signed ;


--token Punct ('/'|'\\'|'_'|'+'|'-'|'!'|'¿'|'¡'|'?'|'!'|'←'|'→') ;
token UIdent ((upper)(letter|digit|'/'|'\\'|'_'|'+'|'-'|'!'|'¿'|'¡'|'?'|'!')*
	      |(digit)(upper|lower|'/'|'\\'|'_'|'+'|'-'|'!'|'¿'|'¡'|'?'|'!')* --if it begins with number, can't end in / or C, because that's ambiguous with positions
		      (upper - ["C"]|lower|'\\'|'_'|'+'|'-'|'!'|'¿'|'¡'|'?'|'!')+
              |('+')(digit|letter|'/'|'\\'|'_'|'+'|'-'|'!'|'¿'|'¡'|'?'|'!')+ 
              |('+'|'-')(letter|'/'|'\\'|'_'|'+'|'-'|'!'|'¿'|'¡'|'?'|'!')+) ;
                   --cannot end in digit if it begins with -

token Id ((letter)(upper|letter|digit|'/'|'_'|'+'|'-'|'!'|'¿'|'¡')*
          |('\\'|'+')(digit|letter|'/'|'\\'|'_'|'+'|'-'|'!'|'¿'|'¡'|'?'|'!')+) ;

token Str ('"' ((char - ["\""]))* '"') ; -- to allow e.g. ("\,") OR ("\:") OR ("\;")

token Signed ('-'? (digit)+) ;