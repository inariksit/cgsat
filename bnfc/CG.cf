
comment "#" ;
comment "SETS" ;
comment "SUBREADINGS" ;
comment "CONSTRAINTS" ;
comment "MAPPINGS" ;
comment "DELIMITERS" ;
comment "SOFT-DELIMITERS" ;
comment "AFTER-SECTIONS" ;
comment "BEFORE-SECTIONS" ;
comment "NULL-SECTION" ;

-- hacks
comment "ADD" ; 
comment "IFF" ;
comment "MAP" ;
comment "SUBSTITUTE" ;



Sections. Grammar ::= [Section] ;
separator nonempty Section "SECTION" ;  --TODO: check if we can use multiple things as a separator (e.g. SECTION / BEFORE-SECTIONS / AFTER-SECTIONS

Defs.  Section ::= [Def] ;
terminator Def "" ;

--------------------------------------------------------------------------------
-- Sets and lists can be defined at the beginning of the grammar
-- Lists are bound by OR with just concatenation:
--   LIST V  = vblex vbser vaux vbhaver vbdo ; --just tags
-- 
-- Sets use "OR" or "|":
--   SET CLB = SENT | V-FIN | Subj ; --named lists

SetDef. Def  ::= SetDecl ;

Set.  SetDecl ::= "SET" SetName "=" TagSet ";" ;
List. SetDecl ::= "LIST" SetName "=" [Tag] ";" ;

-- Set names start with uppercase letter or number 
SetName.  SetName ::= UIdent ;
BOS.      SetName ::= ">>>" ;
EOS.      SetName ::= "<<<" ;
_.        SetName ::= "$$" SetName ; -- Unification; just read them as regular set names


--------------------------------------------------------------------------------
-- Tags can be wordforms or lemmas/wordforms, identifiers or named sets.

Lemma.   Tag1 ::= Str ; 
LemmaCI. Tag1 ::= Str "i" ; 
Tag.     Tag1 ::= Id ;
Named.   Tag1 ::= SetName ;
_.       Tag1 ::= "+" Tag1 ; -- Subreadings; ignore

coercions Tag 1 ;

separator nonempty Tag "" ;

----------------------------------------------------------------------
-- Rules: e.g.
-- REMOVE Foo IF (-1 Bar) 

RuleDef. Def ::= Rule ;

SelectIf. Rule ::= SELECT TagSet MaybeIF [Cond] ";" ;
RemoveIf. Rule ::= REMOVE TagSet MaybeIF [Cond] ";" ;
SelectAlways. Rule ::= SELECT TagSet ";" ;
RemoveAlways. Rule ::= REMOVE TagSet ";" ;
MatchLemma. Rule ::= Str Rule ; --for some reason "<az>" SELECT foo ... doesn't work with String

rules SELECT ::= "SELECT" MaybeName ;
rules REMOVE ::= "REMOVE" MaybeName ;

rules MaybeIF   ::= "IF" | "if" | ;
rules MaybeName ::= ":" Id | ;

--TODO subreading:  SELECT Inf IF (-1/0 ADV-NOT)(-1/1 VAUX-CAN);
CNotPos.  Cond1 ::= "NOT" Position TagSet ;
CPos.     Cond1 ::= Position TagSet ;
CBarrier. Cond1 ::= Position TagSet Barrier ;
CNotBar.  Cond1 ::= "NOT" Position TagSet Barrier ;
CLinked.  Cond  ::= [Cond1] ;
CTempl.   Cond  ::= [Template] ;
_.        Cond ::= "(" Cond ")" ; 


separator nonempty Cond1 "LINK" ;
separator nonempty Cond "" ;

-- Template: REMOVE V-FIN IF (0 Inf) ((1C* V-FIN) OR (-1C* V-FIN));
-- OR separates here conditions, not tagsets.
Templ.    Template ::= "(" Cond1 ")" ;
separator nonempty Template "OR" ;

TagSet.  TagSet  ::= TagSet1 ;
_.       TagSet1 ::= "(" TagSet ")" ; -- you can add parentheses around any tag set

-- Essentially, tags bound by AND are like one tag.
-- These tags are separated by spaces and enclosed in parentheses.
-- Also you can just parenthesise a single tag randomly.
AND.     Tag1 ::= "(" [Tag] ")" ; 

-- OR 
OR.      TagSet1 ::= Tag Or TagSet1 ; 
Diff.    TagSet1 ::= TagSet1 "-" TagSet ;
Cart.    TagSet1 ::= TagSet1 "+" TagSet ;
All.     TagSet1 ::= "(*)" ;
NilT.    TagSet1 ::= Tag ;

rules Or ::= "OR" | "|" ;

Exactly. Position ::= Signed ;
AtLeastPre. Position ::= "*" Signed ;
AtLeastPost. Position ::= Signed "*" ; 
AtLPostCaut. Position ::= Signed "C*" ;
Cautious. Position ::= Position "C" ; --We're not interested in the unambiguous

Barrier. Barrier ::= "BARRIER" TagSet ;


token UIdent ((upper)(upper|letter|digit|'/'|'_'|'+'|'-'|'!'|'¿'|'¡')*
	      |(digit)(upper - ["C"]|lower|'/'|'_'|'+'|'-'|'!'|'¿'|'¡')+) ;
token Id ((letter)(upper|letter|digit|'/'|'_'|'+'|'-'|'!'|'¿'|'¡')*) ;

token Str ('"' ((char - ["\""]))* '"') ; -- to allow e.g. ("\,") OR ("\:") OR ("\;")

token Signed ('-'? (digit)+ ('/' (digit)+)* ) ;


{- Fred Karlsson's CG book 1995:

"The constraint file consists of thirteen sections. The following designated expressions must occur in the following form and order, each followed by sets, function declarations, constraints etc. of the appropriate type:
SENTENCE-DELIMITERS
SET-DECLARATIONS 
SYNTACTIC-FUNCTION-DECLARATIONS 
PRINCIPAL-FUNCTION-DECLARATIONS 
TEMPLATES
MORPHOSYNTACTIC-MAPPINGS 
CLAUSE-BOUNDARY-CONSTRAINTS 
DISAMBIGUATION-CONSTRAINTS 
HEURISTIC-DISAMBIGUATION-CONSTRAINTS 
SYNTACTIC-CONSTRAINTS 
HEURISTIC-SYNTACTIC-CONSTRAINTS 
MORPHOLOGICAL-HEURISTICS 
TEXT-BASED-HEURISTICS
END"
-}