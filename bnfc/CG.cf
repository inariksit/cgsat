
comment "#" ;
comment "SETS" ;
comment "CONSTRAINTS" ;
comment "DELIMITERS" ;
comment "SOFT-DELIMITERS" ;
comment "SECTION" ;
comment "AFTER-SECTIONS" ;

Defs.  Grammar ::= [Def] ;
terminator Def "" ;

--------------------------------------------------------------------------------
-- Sets and lists can be defined at the beginning of the grammar
-- Lists are bound by OR with just concatenation:
--   LIST V  = vblex vbser vaux vbhaver vbdo ; --just tags
-- 
-- Sets use "OR" or "|":
--   SET CLB = SENT | V-FIN | Subj ; --named lists

SetDef. Def  ::= SetDecl ;

Set.  SetDecl ::= "SET" SetName "=" TagSet ";" ;
List. SetDecl ::= "LIST" SetName "=" [Tag] ";" ;

-- Set names start with uppercase letter or number 
-- (this is annoying, because 
SetName.  SetName ::= UIdent ;
EOS.      SetName ::= "<<<" ;
BOS.      SetName ::= ">>>" ;
_.        SetName ::= "$$" SetName ; --Subreadings; just read them as regular set names


--------------------------------------------------------------------------------
-- Tags can be wordforms or lemmas/wordforms, identifiers or named sets.

Lemma.   Tag1 ::= String ; 
Tag.     Tag1 ::= Id ;
Named.   Tag1 ::= SetName ;

coercions Tag 1 ;

separator nonempty Tag "" ;

----------------------------------------------------------------------
-- Rules: e.g.
-- REMOVE Foo IF (-1 Bar) 

-- More complex:
-- REMOVE V-FIN IF (0 Inf OR V-FIN) ((1C* V-FIN BARRIER CLB) OR (-1C* V-FIN BARRIER CLB));
--TODO templates

RuleDef. Def ::= Rule ;

SelectIf. Rule ::= SELECT TagSet MaybeIF [Cond] ";" ;
RemoveIf. Rule ::= REMOVE TagSet MaybeIF [Cond] ";" ;
SelectAlways. Rule ::= SELECT TagSet ";" ;
RemoveAlways. Rule ::= REMOVE TagSet ";" ;
MatchLemma. Rule ::= String Rule ;

rules SELECT ::= "SELECT" MaybeName ;
rules REMOVE ::= "REMOVE" MaybeName ;

rules MaybeIF   ::= "IF" | "if" | ;
rules MaybeName ::= ":" Id | ;

CNotPos.  Cond1 ::= "NOT" Position TagSet ;
CPos.     Cond1 ::= Position TagSet ;
CBarrier. Cond1 ::= Position TagSet Barrier ;
CNotBar.  Cond1 ::= "NOT" Position TagSet Barrier ;
Linked.   Cond  ::= [Cond1] ;
_.        Cond ::= "(" Cond ")" ; 


separator nonempty Cond1 "LINK" ;
separator nonempty Cond "" ;

-- REMOVE V-FIN IF (0 Inf) (0 Inf OR V-FIN) ((1C* V-FIN BARRIER CLB) OR (-1C* V-FIN BARRIER CLB));

TagSet.  TagSet  ::= TagSet1 ;
_.       TagSet1 ::= "(" TagSet ")" ; -- you can add parentheses around any tag set

-- Essentially, tags bound by AND are like one tag.
-- These tags are separated by spaces and enclosed in parentheses.
-- Also you can just parenthesise a single tag randomly.
AND.     Tag1 ::= "(" [Tag] ")" ; 

-- OR 
OR.      TagSet1 ::= Tag Or TagSet1 ; 
Diff.    TagSet1 ::= TagSet1 "-" TagSet ;
Cart.    TagSet1 ::= TagSet1 "+" TagSet ;
All.     TagSet1 ::= "(*)" ;
NilT.    TagSet1 ::= Tag ;

rules Or ::= "OR" | "|" ;

Exactly. Position ::= Signed ;
AtLeastPre. Position ::= "*" Signed ;
AtLeastPost. Position ::= Signed "*" ; 
AtLPostUnam. Position ::= Signed "C*" ;
_. Position ::= Position "C" ; --We're not interested in the unambiguous

Barrier. Barrier ::= "BARRIER" TagSet ;




token UIdent ((upper)(upper|letter|digit|'/'|'_'|'+'|'-'|'!'|'¿'|'¡')*
              |('>')+|('<')+
	      |(digit)(upper - ["C"]|lower|'/'|'_'|'+'|'-'|'!'|'¿'|'¡')+) ;
token Id ((letter)(upper|letter|digit|'/'|'_'|'+'|'-'|'!'|'¿'|'¡')*
              |('>')+|('<')+) ;
	     -- |(digit)(upper|letter|'/'|'_'|'+'|'-'|'!'|'¿'|'¡')+) ;

token Signed ('-'? (digit)+ ('/' (digit)+)* ) ;


{- Fred Karlsson's CG book 1995:

"The constraint file consists of thirteen sections. The following designated expressions must occur in the following form and order, each followed by sets, function declarations, constraints etc. of the appropriate type:
SENTENCE-DELIMITERS
SET-DECLARATIONS 
SYNTACTIC-FUNCTION-DECLARATIONS 
PRINCIPAL-FUNCTION-DECLARATIONS 
TEMPLATES
MORPHOSYNTACTIC-MAPPINGS 
CLAUSE-BOUNDARY-CONSTRAINTS 
DISAMBIGUATION-CONSTRAINTS 
HEURISTIC-DISAMBIGUATION-CONSTRAINTS 
SYNTACTIC-CONSTRAINTS 
HEURISTIC-SYNTACTIC-CONSTRAINTS 
MORPHOLOGICAL-HEURISTICS 
TEXT-BASED-HEURISTICS
END"
-}